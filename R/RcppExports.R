# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' MCMC from a hierarchical GSI model for rho, pi, and the individual posterior probabilities,
#' with misassignment-scaling
#'
#' Using a matrix of scaled likelihoods, this function samples the posteriors and values of rho,
#' then samples values of omega scaled by their corresponding rho and the inverse of their
#' average rate of correct assignment.  It returns the output in a list.
#'
#'
#' @param SL  matrix of the scaled likelihoods.  This is should have values for each individual in a column
#' (going down in the rows are values for different populations).
#' @param Omega_init  Starting value for the omega (collection mixing proportion) vector.
#' @param Rho_init Starting value for the rho (reporting unit mixing proportion) vector.
#' @param reps total number of reps (sweeps) to do.
#' @param burn_in how many reps to discard in the beginning when doing the mean calculation.
#' They will still be returned in the traces if desired
#' @param sample_int_Pi the number of reps between samples being taken for Pi traces.
#' If 0 no trace samples are taken
#' @param sample_int_PofZ the number of reps between samples being taken for the traces of
#' posterior of each individual's origin. If 0 no trace samples are taken.
#' @param sample_int_PofR the number of reps between samples being taken for the traces of
#' posterior reporting unit of each individual's origin. If 0 no trace samples are taken.
#' @param RU_starts a vector of length(rho.size()) + 1, where each element delineates
#' the starting index of a reporting unit in RU_vec (last element is total # collections)
#' @param RU_vec a vector of collection indices, grouped by reporting unit, with groups
#' delineated in RU_starts
#' @param miss_coll2RU a vector of rates at which each collection is misassigned
#' to a different reporting unit; in the same order as RU_vec
#'
#' @examples
#' params <- tcf2param_list(alewife, 15)
#' logl <- geno_logL(params)
#' SL <- apply(exp(logl), 2, function(x) x/sum(x))
#' avg_correct <- avg_coll2correctRU(SL, params$coll,params$RU_starts, params$RU_vec)
#' lambda_omega <- rep(1/params$C, params$C)
#' lambda_rho <- rep(1/(length(params$RU_starts)-1), length(params$RU_starts)-1 )
#' test_bh_mcmc <- gsi_mcmc_2(SL, lambda_rho, lambda_omega, lambda_rho, lambda_omega, 10000, 2500, 50, 50, 50, 50, params$RU_starts, params$RU_vec, avg_correct)
#'
#' @return \code{gsi_mcmc_2} returns a nested list of MCMC results.
#'
#' \code{$mean} records the mean
#' sampled values for rho and omega in vectors, as well as a matrix of the posterior probability of
#' assignment for every in individual (column) to a collection (PofZ, rows) or reporting unit (PofR, rows)
#'
#' \code{$sd} records the standard deviations for the same values. Sampling for both \code{sd}
#' and \code{mean} are only begun after the burn-in period.
#'
#' \code{$trace} is a list, with each element being a list of samples for the relevant variable
#' (rho, omega, PofZ, PofR) taken at the chosen sampling interval. If the sampling interval for
#' any parameter == 0, that list is empty.
#'
#' @export
gsi_mcmc_2 <- function(SL, Rho_init, Omega_init, lambda_rho, lambda_omega, reps, burn_in, sample_int_omega, sample_int_rho, sample_int_PofZ, sample_int_PofR, RU_starts, RU_vec, coll2correctRU) {
    .Call('rubias_gsi_mcmc_2', PACKAGE = 'rubias', SL, Rho_init, Omega_init, lambda_rho, lambda_omega, reps, burn_in, sample_int_omega, sample_int_rho, sample_int_PofZ, sample_int_PofR, RU_starts, RU_vec, coll2correctRU)
}

#' Draw all allele counts for a population from a vector of allele counts
#'
#' (This is a test for our allele count vector indexing macro)
#' @param c the collection index desired
#' @param l the locus desired
#' @param ac_v the vector of allele counts
#' @param L the total number of loci
#' @param C the total number of collections
#' @param A an integer vector of alleles in each population
#' @param CA an integer vector of the cumulative number of alleles at all previous loci in the vector
#'
#' @export
coll_ac <- function(l, c, ac_v, L, C, A, CA) {
    .Call('rubias_coll_ac', PACKAGE = 'rubias', l, c, ac_v, L, C, A, CA)
}

#' Fetch individual genotypes from a locus and population
#'
#' (This is a test case for our individual indexing macro)
#'
#' @param i the index of the desired individual to sample
#' @param l the index of the desired locus
#' @param I_v a vector of individual genotypes, created by unlisting allelic_list output
#' @param P Ploidy
#' @param I Total number of individuals
#'
#' @export
genotype_i <- function(l, i, I_v, P, I) {
    .Call('rubias_genotype_i', PACKAGE = 'rubias', l, i, I_v, P, I)
}

#' Calculate list of genotype likelihoods
#'
#' @param par_list genetic data converted to the param_list format by tcf2param_list
#'
#' @examples
#' example(tcf2param_list)
#' ale_glL <- geno_logL(ale_par_list)
#' @export
geno_logL <- function(par_list) {
    .Call('rubias_geno_logL', PACKAGE = 'rubias', par_list)
}

#' Calculate list of genotype likelihoods
#'
#' @param par_list genetic data converted to the param_list format by tcf2param_list
#'
#' @examples
#' example(tcf2param_list)
#' ale_glL <- geno_logL(ale_par_list)
#' @export
geno_logL_RU <- function(par_list) {
    .Call('rubias_geno_logL_RU', PACKAGE = 'rubias', par_list)
}

#' Sample 1 observation from cell probabilities that are columns of a matrix
#'
#' blah blah...
#' @param M a matrix whose columns are reals summing to one
#'
#' @export
samp_from_mat <- function(M) {
    .Call('rubias_samp_from_mat', PACKAGE = 'rubias', M)
}

#' Simulate genotype log-likelihoods from a population by gene copy
#'
#' @param par_list genetic data converted to the param_list format by tcf2param_list
#'
#' @param sim_colls a vector of indices for the collections desired for simulation;
#' each element of the list corresponds to an individual
#'
#'
#' @return \code{gprob_sim} returns a matrix of the summed log-likelihoods
#' for all loci of a simulated population mixture; columns represent individuals,
#' with each row containing their log-likelihood of belonging to the collection
#' of the same index, given the selection of two independent gene copies from the desired
#' collection of origin's reference allele frequencies
#'
#' @examples
#' example(tcf2param_list)
#' sim_colls <- sample(ale_par_list$C, 1070, replace = T)
#' ale_sim_gprobs_gc <- gprob_sim_gc(ale_par_list, sim_colls)
#' ale_sim_gprobs_ind <- gprob_sim_ind(ale_par_list, sim_colls)
#'
#' @export
gprob_sim_gc <- function(par_list, sim_colls) {
    .Call('rubias_gprob_sim_gc', PACKAGE = 'rubias', par_list, sim_colls)
}

#' Simulate genotype log-likelihoods from a population by individual
#'
#' @param par_list genetic data converted to the param_list format by tcf2param_list
#'
#' @param sim_colls a vector of indices for the collections desired for simulation;
#' each element of the list corresponds to an individual
#'
#'
#' @return \code{gprob_sim} returns a matrix of the summed log-likelihoods
#' for all loci of a simulated population mixture; columns represent individuals,
#' with each row containing their log-likelihood of belonging to the collection
#' of the same index, given the selection of an individual's genotype from the
#' reference collection of interest. Selection at the locus and gene copy level
#' are not independent, and missing data is included in selection.
#'
#' @examples
#' example(tcf2param_list)
#' sim_colls <- sample(ale_par_list$C, 1070, replace = T)
#' ale_sim_gprobs <- gprob_sim(ale_par_list, sim_colls)
#'
#' @export
gprob_sim_ind <- function(par_list, sim_colls) {
    .Call('rubias_gprob_sim_ind', PACKAGE = 'rubias', par_list, sim_colls)
}

#' Simulate genotype log-likelihoods from a population by gene copy
#'
#' @param par_list genetic data converted to the param_list format by tcf2param_list
#'
#' @param sim_colls a vector of indices for the collections desired for simulation;
#' each element of the list corresponds to an individual
#'
#'
#' @return \code{gprob_sim} returns a matrix of the summed log-likelihoods
#' for all loci of a simulated population mixture; columns represent individuals,
#' with each row containing their log-likelihood of belonging to the collection
#' of the same index, given the selection of two independent gene copies from the desired
#' collection of origin's reference allele frequencies
#'
#' @examples
#' example(tcf2param_list)
#' sim_colls <- sample(ale_par_list$C, 1070, replace = T)
#' ale_sim_gprobs_gc <- gprob_sim_gc(ale_par_list, sim_colls)
#' ale_sim_gprobs_ind <- gprob_sim_ind(ale_par_list, sim_colls)
#'
#' @export
gprob_sim_gc_RU <- function(par_list, sim_colls, ru_colls) {
    .Call('rubias_gprob_sim_gc_RU', PACKAGE = 'rubias', par_list, sim_colls, ru_colls)
}

#' Simulate genotype log-likelihoods from a population by individual for Ben's experiment
#'
#' @param par_list genetic data converted to the param_list format by tcf2param_list
#'
#' @param sim_colls a vector of indices for the collections desired for simulation;
#' each element of the list corresponds to an individual
#'
#'
#' @return \code{gprob_sim} returns a matrix of the summed log-likelihoods
#' for all loci of a simulated population mixture; columns represent individuals,
#' with each row containing their log-likelihood of belonging to the collection
#' of the same index, given the selection of an individual's genotype from the
#' reference collection of interest. Selection at the locus and gene copy level
#' are not independent, and missing data is included in selection.
#'
#' @examples
#' example(tcf2param_list)
#' sim_colls <- sample(ale_par_list$C, 1070, replace = T)
#' ale_sim_gprobs <- gprob_sim(ale_par_list, sim_colls)
#'
#' @export
gprob_sim_ind_RU <- function(par_list, sim_colls) {
    .Call('rubias_gprob_sim_ind_RU', PACKAGE = 'rubias', par_list, sim_colls)
}

#' Simulate genotypes by gene copy, with missing data from chosen individuals
#'
#' @param par_list list_diploid_params output
#' @param sim_colls a vector length I of collections from which to sample the genotypes
#' for individual i
#' @param sim_missing a vector of length I of indices for individuals in I_list
#' whose missing data should be copied for individual i
#'
#' @export
gprob_sim_gc_missing <- function(par_list, sim_colls, sim_missing) {
    .Call('rubias_gprob_sim_gc_missing', PACKAGE = 'rubias', par_list, sim_colls, sim_missing)
}

#' EM algorithm from the simplest GSI model for pi and the individual posterior probabilities
#'
#' Using a matrix of scaled likelihoods, this function does an EM algorithm to climb the
#' likelihood surface for pi, and computes the plug-in estimate of the posteriors
#' for all the individuals.  It returns the output in a list.
#' @param SL  a matrix of the scaled likelihoods.  This is should have values for each individual in a column
#' (going down in the rows are values for different collections).
#' @param Pi_init  Starting value for the pi (collection mixture proportion) vector.
#' @param max_iterations the maximum total number of reps iterations to do.
#' @param tolerance the EM-algorithm will be considered converged when the sum over the elements of pi of the absolute value
#' of the difference between the previous and the current estimate is less than tolerance.
#' @param return_progression  If true, then the pi_trace component of the output shows the value of pi visited en route to the end.
#'
#' @return \code{gsi_em_1} returns a final Maximum-Likelihood estimate for pi and PofZ, as well as the number
#'
#' @examples
#' params <- tcf2param_list(alewife, 15)
#' logl <- geno_logL(params)
#' SL <- apply(exp(logl), 2, function(x) x/sum(x))
#' test_em <- gsi_em_1(SL, rep(1/params$C, params$C), max_iterations = 10^6, tolerance = 10^-7, return_progression = TRUE)
#'
#' @export
gsi_em_1 <- function(SL, Pi_init, max_iterations, tolerance, return_progression) {
    .Call('rubias_gsi_em_1', PACKAGE = 'rubias', SL, Pi_init, max_iterations, tolerance, return_progression)
}

#' MCMC from the simplest GSI model for pi and the individual posterior probabilities
#'
#' Using a matrix of scaled likelihoods this function samples values of pi and the posteriors
#' for all the individuals.  It returns the output in a list.
#' @param SL  matrix of the scaled likelihoods.  This is should have values for each individual in a column
#' (going down in the rows are values for different populations).
#' @param Pi_init  Starting value for the pi (colelction mixture proportion) vector.
#' @param lambda the prior to be added to the allocated individuals in order to generate pseudo-count
#' Dirichlet parameters for the simulation of a new pi vector
#' @param reps total number of reps (sweeps) to do.
#' @param burn_in how many reps to discard in the beginning when doing the mean calculation. They will still be
#' returned in the traces if desired
#' @param sample_int_Pi the number of reps between samples being taken for Pi traces.  If 0 no trace samples are taken
#' @param sample_int_PofZ the number of reps between samples being taken for the traces of posterior of each individual's origin. If 0
#' no trace samples are taken.
#'
#' @examples
#' params <- tcf2param_list(alewife, 15)
#' logl <- geno_logL(params)
#' SL <- apply(exp(logl), 2, function(x) x/sum(x))
#' lambda <- rep(1/params$C, params$C)
#' mcmc <- test_gsi_mcmc_1(SL, lambda, lambda, 10000, 2500, 50, 50)
#'
#' @export
gsi_mcmc_1 <- function(SL, Pi_init, lambda, reps, burn_in, sample_int_Pi, sample_int_PofZ) {
    .Call('rubias_gsi_mcmc_1', PACKAGE = 'rubias', SL, Pi_init, lambda, reps, burn_in, sample_int_Pi, sample_int_PofZ)
}

#' Given a vector of different categories in 1...n and a prior,
#' simulate a Dirichlet random vector
#'
#' Takes a vector of collection indices to which individuals (vector elements) were assigned,
#' and returns a Dirichlet random variable generated by adding the prior to the sum
#' of each collection's occurences, and simulating an alpha from a gamma distribution
#' with this shape parameter.
#'
#' The categories are labeled in C from 1 up to n.  n is the length of \code{lambda},
#' which is a vector of priors. Note that all elements of \code{lambda}
#' must be strictly greater than 0.
#'
#' @param C  a vector giving different categories of individual
#' (not counts of categories - untabulated)
#' @param lambda priors for the categories
#' @export
dirch_from_allocations <- function(C, lambda) {
    .Call('rubias_dirch_from_allocations', PACKAGE = 'rubias', C, lambda)
}

#' Given a vector of counts for different categories in 1...n and a prior,
#' simulate a Dirichlet random vector
#'
#' Takes a vector of counts for 1:n collections,
#' and returns a Dirichlet random variable generated by adding the prior to each
#' collection value, and simulating an alpha from a gamma distribution
#' with this shape parameter.
#'
#' The categories are labeled in C from 1 up to n.  n is the length of \code{lambda},
#' which is a vector of priors. Note that all elements of \code{lambda}
#' must be strictly greater than 0.
#' @param C  a vector giving counts of categories
#' @param lambda priors for the categories
#' @export
dirch_from_counts <- function(C, lambda) {
    .Call('rubias_dirch_from_counts', PACKAGE = 'rubias', C, lambda)
}

