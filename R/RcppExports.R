# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' MCMC from the simplest GSI model for pi and the individual posterior probabilities
#'
#' Using a matrix of scaled likelihoods this function samples values of pi and the posteriors
#' for all the individuals.  It returns the output in a list.
#' @param SL  matrix of the scaled likelihoods.  This is should have values for each individual in a column
#' (going down in the rows are values for different populations).
#' @param Omega_init  Starting value for the omega vector.
#' @param Rho_init Starting value for the rho vector.
#' @param reps total number of reps (sweeps) to do.
#' @param burn_in how many reps to discard in the beginning when doing the mean calculation. They will still be
#' returned in the traces if desired
#' @param sample_int_Pi the number of reps between samples being taken for Pi traces.  If 0 no trace samples are taken
#' @param sample_int_PofZ the number of reps between samples being taken for the traces of posterior of each individual's origin. If 0
#' no trace samples are taken.
#' @param RU_starts a vector of length(rho.size()) + 1, where each element delineates the starting index of a reporting unit in RU_vec (last element is total # collections)
#' @param RU_vec a vector of collection indices, grouped by reporting unit, with groups delineated in RU_starts
#' @param miss_coll2RU a vector of rates at which each collection is misassigned to a different reporting unit;
#' in the same order as RU_vec
#'
#' @examples
#' params <- tcf2param_list(alewife, 15)
#' logl <- geno_logL(params)
#' SL <- apply(exp(logl), 2, function(x) x/sum(x))
#' lambda_omega <- rep(1/params$C, params$C)
#' lambda_rho <- rep(1/(length(params$RU_starts)-1), length(params$RU_starts)-1 )
#' test_bh_mcmc <- gsi_mcmc_2(SL, lambda_rho, lambda_omega, lambda_rho, lambda_omega, 10000, 2500, 50, 50, 50, 50, params$RU_starts, params$RU_vec)
#'
#' @export
gsi_mcmc_2 <- function(SL, Rho_init, Omega_init, lambda_rho, lambda_omega, reps, burn_in, sample_int_omega, sample_int_rho, sample_int_PofZ, sample_int_PofR, RU_starts, RU_vec, coll2correctRU) {
    .Call('rubias_gsi_mcmc_2', PACKAGE = 'rubias', SL, Rho_init, Omega_init, lambda_rho, lambda_omega, reps, burn_in, sample_int_omega, sample_int_rho, sample_int_PofZ, sample_int_PofR, RU_starts, RU_vec, coll2correctRU)
}

#' Draw all allele counts for a population from a vector of allele counts
#'
#' (This is a test for our allele count vector indexing macro)
#' @param c the collection index desired
#' @param l the locus desired
#' @param ac_v the vector of allele counts
#' @param L the total number of loci
#' @param C the total number of collections
#' @param A an integer vector of alleles in each population
#' @param CA an integer vector of the cumulative number of alleles at all previous loci in the vector
#'
#' @export
coll_ac <- function(l, c, ac_v, L, C, A, CA) {
    .Call('rubias_coll_ac', PACKAGE = 'rubias', l, c, ac_v, L, C, A, CA)
}

#' Fetch individual genotypes from a locus and population
#'
#' (This is a test case for our individual indexing macro)
#'
#' @param i the index of the desired individual to sample
#' @param l the index of the desired locus
#' @param I_v a vector of individual genotypes, created by unlisting allelic_list output
#' @param P Ploidy
#' @param I Total number of individuals
#'
#' @export
genotype_i <- function(l, i, I_v, P, I) {
    .Call('rubias_genotype_i', PACKAGE = 'rubias', l, i, I_v, P, I)
}

#' Calculate list of genotype likelihoods
#'
#' @param par_list genetic data converted to the param_list format by tcf2param_list
#'
#' @examples
#' example(tcf2param_list)
#' ale_glL <- geno_logL(ale_par_list)
#' @export
geno_logL <- function(par_list) {
    .Call('rubias_geno_logL', PACKAGE = 'rubias', par_list)
}

#' Calculate list of genotype likelihoods
#'
#' @param par_list genetic data converted to the param_list format by tcf2param_list
#'
#' @examples
#' example(tcf2param_list)
#' ale_glL <- geno_logL(ale_par_list)
#' @export
geno_logL_RU <- function(par_list) {
    .Call('rubias_geno_logL_RU', PACKAGE = 'rubias', par_list)
}

#' Sample 1 observation from cell probabilities that are columns of a matrix
#'
#' blah blah...
#' @param M a matrix whose columns are reals summing to one
#'
#' @export
samp_from_mat <- function(M) {
    .Call('rubias_samp_from_mat', PACKAGE = 'rubias', M)
}

#' Simulate genotype log-likelihoods from a population by gene copy
#'
#' @param par_list genetic data converted to the param_list format by tcf2param_list
#'
#' @param sim_colls a vector of indices for the collections desired for simulation;
#' each element of the list corresponds to an individual
#'
#'
#' @return \code{gprob_sim} returns a matrix of the summed log-likelihoods
#' for all loci of a simulated population mixture; columns represent individuals,
#' with each row containing their log-likelihood of belonging to the collection
#' of the same index, given the selection of two independent gene copies from the desired
#' collection of origin's reference allele frequencies
#'
#' @examples
#' example(tcf2param_list)
#' sim_colls <- sample(ale_par_list$C, 1070, replace = T)
#' ale_sim_gprobs_gc <- gprob_sim_gc(ale_par_list, sim_colls)
#' ale_sim_gprobs_ind <- gprob_sim_ind(ale_par_list, sim_colls)
#'
#' @export
gprob_sim_gc <- function(par_list, sim_colls) {
    .Call('rubias_gprob_sim_gc', PACKAGE = 'rubias', par_list, sim_colls)
}

#' Simulate genotype log-likelihoods from a population by individual
#'
#' @param par_list genetic data converted to the param_list format by tcf2param_list
#'
#' @param sim_colls a vector of indices for the collections desired for simulation;
#' each element of the list corresponds to an individual
#'
#'
#' @return \code{gprob_sim} returns a matrix of the summed log-likelihoods
#' for all loci of a simulated population mixture; columns represent individuals,
#' with each row containing their log-likelihood of belonging to the collection
#' of the same index, given the selection of an individual's genotype from the
#' reference collection of interest. Selection at the locus and gene copy level
#' are not independent, and missing data is included in selection.
#'
#' @examples
#' example(tcf2param_list)
#' sim_colls <- sample(ale_par_list$C, 1070, replace = T)
#' ale_sim_gprobs <- gprob_sim(ale_par_list, sim_colls)
#'
#' @export
gprob_sim_ind <- function(par_list, sim_colls) {
    .Call('rubias_gprob_sim_ind', PACKAGE = 'rubias', par_list, sim_colls)
}

#' Simulate genotype log-likelihoods from a population by gene copy
#'
#' @param par_list genetic data converted to the param_list format by tcf2param_list
#'
#' @param sim_colls a vector of indices for the collections desired for simulation;
#' each element of the list corresponds to an individual
#'
#'
#' @return \code{gprob_sim} returns a matrix of the summed log-likelihoods
#' for all loci of a simulated population mixture; columns represent individuals,
#' with each row containing their log-likelihood of belonging to the collection
#' of the same index, given the selection of two independent gene copies from the desired
#' collection of origin's reference allele frequencies
#'
#' @examples
#' example(tcf2param_list)
#' sim_colls <- sample(ale_par_list$C, 1070, replace = T)
#' ale_sim_gprobs_gc <- gprob_sim_gc(ale_par_list, sim_colls)
#' ale_sim_gprobs_ind <- gprob_sim_ind(ale_par_list, sim_colls)
#'
#' @export
gprob_sim_gc_RU <- function(par_list, sim_colls, ru_colls) {
    .Call('rubias_gprob_sim_gc_RU', PACKAGE = 'rubias', par_list, sim_colls, ru_colls)
}

#' Simulate genotype log-likelihoods from a population by individual for Ben's experiment
#'
#' @param par_list genetic data converted to the param_list format by tcf2param_list
#'
#' @param sim_colls a vector of indices for the collections desired for simulation;
#' each element of the list corresponds to an individual
#'
#'
#' @return \code{gprob_sim} returns a matrix of the summed log-likelihoods
#' for all loci of a simulated population mixture; columns represent individuals,
#' with each row containing their log-likelihood of belonging to the collection
#' of the same index, given the selection of an individual's genotype from the
#' reference collection of interest. Selection at the locus and gene copy level
#' are not independent, and missing data is included in selection.
#'
#' @examples
#' example(tcf2param_list)
#' sim_colls <- sample(ale_par_list$C, 1070, replace = T)
#' ale_sim_gprobs <- gprob_sim(ale_par_list, sim_colls)
#'
#' @export
gprob_sim_ind_RU <- function(par_list, sim_colls) {
    .Call('rubias_gprob_sim_ind_RU', PACKAGE = 'rubias', par_list, sim_colls)
}

#' Simulate genotypes by gene copy, with missing data from chosen individuals
#'
#' @param par_list list_diploid_params output
#' @param sim_colls a vector length I of collections from which to sample the genotypes
#' for individual i
#' @param sim_missing a vector of length I of indices for individuals in I_list
#' whose missing data should be copied for individual i
#'
#' @export
gprob_sim_gc_missing <- function(par_list, sim_colls, sim_missing) {
    .Call('rubias_gprob_sim_gc_missing', PACKAGE = 'rubias', par_list, sim_colls, sim_missing)
}

#' do EM algorithm from the simplest GSI model for pi and the individual posterior probabilities
#'
#' Using a matrix of scaled likelihoods this function does an EM algorithm to climb the likelihood surface
#' for pi and and the end computes the plug-in estimate of the posteriors
#' for all the individuals.  It returns the output in a list.
#' @param SL  matrix of the scaled likelihoods.  This is should have values for each individual in a column
#' (going down in the rows are values for different populations).
#' @param Pi_init  Starting value for the pi vector.
#' @param max_iterations the maximum total number of reps iterations to do.
#' @param tolerance the EM-algorithm will be considered converged when the sum over the elements of pi of the absolute value
#' of the difference between the previous and the current estimate is less than tolerance.
#' @param return_progression  If true, then the pi_trace component of the output shows the value of pi visited en route to the end.
#' @export
gsi_em_1 <- function(SL, Pi_init, max_iterations, tolerance, return_progression) {
    .Call('rubias_gsi_em_1', PACKAGE = 'rubias', SL, Pi_init, max_iterations, tolerance, return_progression)
}

#' do MCMC from the simplest GSI model for pi and the individual posterior probabilities
#'
#' Using a matrix of scaled likelihoods this function samples values of pi and the posteriors
#' for all the individuals.  It returns the output in a list.
#' @param SL  matrix of the scaled likelihoods.  This is should have values for each individual in a column
#' (going down in the rows are values for different populations).
#' @param Pi_init  Starting value for the pi vector.
#' @param reps total number of reps (sweeps) to do.
#' @param burn_in how many reps to discard in the beginning when doing the mean calculation. They will still be
#' returned in the traces if desired
#' @param sample_int_Pi the number of reps between samples being taken for Pi traces.  If 0 no trace samples are taken
#' @param sample_int_PofZ the number of reps between samples being taken for the traces of posterior of each individual's origin. If 0
#' no trace samples are taken.
#'
#' @examples
#' params <- tcf2param_list(alewife, 15)
#' logl <- geno_logL(params)
#' SL <- apply(exp(logl), 2, function(x) x/sum(x))
#' lambda <- rep(1/params$C, params$C)
#' mcmc <- test_gsi_mcmc_1(SL, lambda, lambda, 10000, 2500, 50, 50)
#'
#' @export
gsi_mcmc_1 <- function(SL, Pi_init, lambda, reps, burn_in, sample_int_Pi, sample_int_PofZ) {
    .Call('rubias_gsi_mcmc_1', PACKAGE = 'rubias', SL, Pi_init, lambda, reps, burn_in, sample_int_Pi, sample_int_PofZ)
}

#' given a vector of different categories in 1...n and a prior simulate a dirichlet r.v.
#'
#' The categories are labeled in C from 1 up to n.  n is the length of pi which is vector of priors.
#' Note that all elements of pi must be strictly greater than 0.
#' @param C  a vector giving different categories of individual (not counts of categories---must be tabulated)
#' @param pi  priors for the categories
#' @export
dirch_from_allocations <- function(C, lambda) {
    .Call('rubias_dirch_from_allocations', PACKAGE = 'rubias', C, lambda)
}

#' given a vector of different categories in 1...n and a prior simulate a dirichlet r.v.
#'
#' The categories are labeled in C from 1 up to n.  n is the length of pi which is vector of priors.
#' Note that all elements of pi must be strictly greater than 0.
#' @param C  a vector giving counts of categories
#' @param pi  priors for the categories
#' @export
dirch_from_counts <- function(C, lambda) {
    .Call('rubias_dirch_from_counts', PACKAGE = 'rubias', C, lambda)
}

